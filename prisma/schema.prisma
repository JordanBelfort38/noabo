generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  gdprConsent     Boolean   @default(false)
  gdprConsentAt   DateTime?
  role            String    @default("user") // "user" | "admin"
  bridgeUserUuid  String?   // Bridge API user UUID
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  accounts              Account[]
  sessions              Session[]
  bankConnections       BankConnection[]
  bankAccounts          BankAccount[]
  transactions          Transaction[]
  subscriptions         Subscription[]
  cancellationRequests  CancellationRequest[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@index([email])
}

model BankConnection {
  id              String   @id @default(cuid())
  userId          String
  provider        String   // "bridge", "tink", "manual"
  providerItemId  String?  // External provider's item/connection ID
  accessToken     String?  @db.Text // Encrypted
  refreshToken    String?  @db.Text // Encrypted
  status          String   @default("active") // active, error, expired, revoked
  consentExpiresAt DateTime?
  lastSyncAt      DateTime?
  lastSyncError   String?
  bankName        String?
  bankLogoUrl     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankAccounts BankAccount[]

  @@index([userId])
  @@index([provider, providerItemId])
}

model BankAccount {
  id               String  @id @default(cuid())
  userId           String
  bankConnectionId String?
  providerAccountId String? // External provider's account ID
  name             String  // "Compte courant", "Livret A", etc.
  iban             String? // Masked IBAN
  currency         String  @default("EUR")
  balance          Int?    // Balance in cents
  balanceDate      DateTime?
  accountType      String  @default("checking") // checking, savings, card
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankConnection BankConnection? @relation(fields: [bankConnectionId], references: [id], onDelete: SetNull)
  transactions   Transaction[]

  @@index([userId])
  @@index([bankConnectionId])
}

model Transaction {
  id              String   @id @default(cuid())
  userId          String
  bankAccountId   String?
  externalId      String?  // External provider's transaction ID
  date            DateTime
  description     String
  rawDescription  String?  // Original description before normalization
  amount          Int      // Amount in cents (negative = debit)
  currency        String   @default("EUR")
  category        String?  // "subscription", "groceries", "transport", etc.
  merchantName    String?  // Normalized merchant name
  importSource    String   @default("manual") // "api", "csv", "pdf", "ofx", "manual"
  importDate      DateTime @default(now())
  isRecurring     Boolean  @default(false)
  metadata        Json?    // Extra data (file name, parser info, etc.)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankAccount BankAccount? @relation(fields: [bankAccountId], references: [id], onDelete: SetNull)

  @@unique([userId, externalId])
  @@index([userId, date])
  @@index([userId, merchantName])
  @@index([userId, isRecurring])
  @@index([bankAccountId])
}

model Subscription {
  id                String    @id @default(cuid())
  userId            String
  merchantName      String
  displayName       String?   // User-customizable name
  amount            Int       // Amount in cents (positive)
  currency          String    @default("EUR")
  frequency         String    // WEEKLY, BIWEEKLY, MONTHLY, BIMONTHLY, QUARTERLY, SEMIANNUAL, ANNUAL
  category          String?   // streaming, telecom, insurance, etc.
  status            String    @default("ACTIVE") // ACTIVE, PAUSED, CANCELED, ENDING_SOON
  confidence        Int       @default(0) // 0-100 detection confidence
  nextChargeDate    DateTime?
  lastChargeDate    DateTime?
  firstChargeDate   DateTime?
  commitmentEndDate DateTime? // Contract end date
  cancellationUrl   String?   // URL to cancel
  notes             String?
  transactionIds    String[]  // IDs of matched transactions
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  cancellationRequests CancellationRequest[]

  @@index([userId])
  @@index([userId, status])
  @@index([userId, merchantName])
}

model CancellationTemplate {
  id                String   @id @default(cuid())
  merchantName      String   @unique // Normalized name matching Transaction.merchantName
  displayName       String   // Display name (e.g., "Netflix France")
  category          String   // streaming, software, utilities, etc.

  // Cancellation methods available
  onlineUrl         String?  // Direct URL to cancel online
  emailAddress      String?  // Email address for cancellation
  phoneNumber       String?  // Phone number to call
  postalAddress     String?  // Postal address for registered mail

  // Method requirements
  difficulty        String   // EASY, MEDIUM, HARD
  requiresCall      Boolean  @default(false)
  requiresLetter    Boolean  @default(false)
  noticeRequired    Int?     // Days of notice required

  // Templates in French
  emailTemplate     String?  @db.Text
  letterTemplate    String?  @db.Text

  // Step-by-step instructions
  steps             String[]
  requirements      String[]
  tips              String[]

  // Legal information
  lawReference      String?  // "Loi Hamon", "Loi Chatel", etc.
  contractType      String?  // "Sans engagement", "Avec engagement"

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model CancellationRequest {
  id                String    @id @default(cuid())
  userId            String
  subscriptionId    String

  status            String    // PENDING, SENT, CONFIRMED, CANCELLED, FAILED
  method            String    // EMAIL, PHONE, LETTER, ONLINE

  sentAt            DateTime?
  confirmedAt       DateTime?
  effectiveDate     DateTime? // When cancellation becomes effective

  notes             String?   @db.Text
  confirmationFile  String?   // Path to uploaded confirmation document

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription      Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([subscriptionId])
  @@index([status])
}
